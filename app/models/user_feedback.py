"""
User Feedback Models - Phase 2 Feedback Loop
Stores user feedback on AI responses for continuous learning
"""

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, timezone
from enum import Enum


class FeedbackRating(str, Enum):
    """Rating type for feedback"""
    helpful = "helpful"
    not_helpful = "not_helpful"


class FeedbackType(str, Enum):
    """Type of feedback"""
    message_rating = "message_rating"
    alternative_selection = "alternative_selection"
    correction = "correction"


class FeedbackStatus(str, Enum):
    """Processing status of feedback"""
    pending = "pending"
    processed = "processed"
    used_for_training = "used_for_training"


class UserFeedback(BaseModel):
    """
    User feedback on AI responses
    Saved to Firestore: user_feedback collection
    """
    feedback_id: Optional[str] = None  # Auto-generated by Firestore
    user_id: str = Field(..., description="User who provided feedback")
    message_id: str = Field(..., description="Chat message being rated")
    session_id: Optional[str] = None
    
    # Feedback details
    feedback_type: FeedbackType = FeedbackType.message_rating
    rating: Optional[FeedbackRating] = None
    corrections: List[str] = Field(default_factory=list, description="What was wrong: food, calories, quantity, timing, other")
    comment: Optional[str] = Field(None, description="Additional user comment")
    
    # Message context (for analysis)
    message_data: Optional[Dict[str, Any]] = Field(
        None,
        description="Original message data: text, response, confidence, classification"
    )
    
    # Metadata
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    status: FeedbackStatus = FeedbackStatus.pending
    processed: bool = False
    processed_at: Optional[datetime] = None
    
    class Config:
        use_enum_values = True
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for Firestore"""
        data = self.model_dump()
        # Convert datetime to ISO string for Firestore
        if self.created_at:
            data['created_at'] = self.created_at.isoformat()
        if self.processed_at:
            data['processed_at'] = self.processed_at.isoformat()
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UserFeedback':
        """Create from Firestore dict"""
        # Convert ISO strings back to datetime
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        if 'processed_at' in data and isinstance(data['processed_at'], str):
            data['processed_at'] = datetime.fromisoformat(data['processed_at'])
        return cls(**data)


class AlternativeSelection(BaseModel):
    """
    User selection of alternative AI interpretation
    Saved to Firestore: alternative_selections collection
    """
    selection_id: Optional[str] = None  # Auto-generated
    user_id: str
    message_id: str
    session_id: Optional[str] = None
    
    # Selection details
    selected_index: int = Field(..., description="Index of selected alternative (0-based)")
    selected_alternative: Dict[str, Any] = Field(..., description="The alternative user chose")
    rejected_primary: Optional[Dict[str, Any]] = Field(None, description="The primary interpretation user rejected")
    
    # Metadata
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for Firestore"""
        data = self.model_dump()
        if self.created_at:
            data['created_at'] = self.created_at.isoformat()
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AlternativeSelection':
        """Create from Firestore dict"""
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        return cls(**data)


class FeedbackRequest(BaseModel):
    """Request model for POST /chat/feedback"""
    message_id: str = Field(..., description="ID of message being rated")
    rating: FeedbackRating = Field(..., description="helpful or not_helpful")
    corrections: List[str] = Field(default_factory=list, description="What was wrong")
    comment: Optional[str] = Field(None, max_length=500, description="Additional feedback")


class AlternativeSelectionRequest(BaseModel):
    """Request model for POST /chat/select-alternative"""
    message_id: str = Field(..., description="ID of original message")
    selected_index: int = Field(..., ge=0, description="Index of selected alternative")
    selected_alternative: Dict[str, Any] = Field(..., description="The alternative data")
    rejected_primary: Optional[Dict[str, Any]] = None


class FeedbackResponse(BaseModel):
    """Response model for feedback endpoints"""
    success: bool
    feedback_id: Optional[str] = None
    message: str
    error: Optional[str] = None




